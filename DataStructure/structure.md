# 5. DataStructure
**:book: Contents**
* [Array VS LinkedList]()
* [Stack and Queue]()
* [Tree]()
  * [Binary Tree]()
  * [Full Binary Tree]()
  * [Complete Binary Tree]()
  * [BST (Binary Search Tree)]()
* [Binary Heap]()
* [Red-Black Tree]()
* [HashTable]()
* [Graph]()
* [그래프(Graph)와 트리(Tree)의 차이점]()
* [B+ Tree]()


---

## Array

1. 장점
    - 가장 기본적인 자료구조로, 논리적 저장 순서와 물리적 저장 순서가 일치
    - 따라서, 인덱스(Index)로 해당 원소에 접근을 할 수 있음 (a[0] ...)
    - 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 Big-O(1)에 해당 원소로 접근이 가능
    즉, random access가 가능하다는 장점이 있음
2. 단점
    - 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤 (O(1)), 또 한가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸림
    - 만약, 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다.
    - 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift 해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)가 된다.
    - 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 시간 복잡도의 최악의 경우는 O(n)이 된다.
    - 삽입의 경우도 역시, 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1씩 shift 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 됨

## Linked List

1. 개념 및 장점
    - Array의 삽입, 삭제에서 발생하는 문제를 해결하기 위해 고안된 자료구조로 각각의 원소들은 자기 자신 다음에 어떤 원소가 있는지만을 기억하고 있다.
    - 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1) 만에 해결할 수 있음

2. 단점
    - 원하는 위치에 삽입을 하고자하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 함 (Array와 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문에)
    - 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생
    - 결국 LinkedList 자료구조는 search에도 O(n)의 시간 복잡도를 갖고, 삽입, 삭제에 대해서도 O(n)의 시간 복잡도를 갖는다.
    - 하지만, Tree 구조의 근간이 되는 자료구조로써, Tree에서 사용되었을 때 그 유용성이 드러남
    
## Stack and Queue

### Stack
  - 선형 자료구조의 일종으로 Last In First Out (LIFO). 즉, 나중에 들어간 원소가 먼저 나온다. 이것이 Stack의 가장 큰 특징
  - 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다.
  - 그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조

### Queue
  - 선형 자료구조의 일종으로 First In First Qut (FIFO). 즉, 먼저 들어간 놈이 먼저 나온다.
  - Stack과는 반대로 먼저 들어간 놈이 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다.
  
## Tree

- 비선형 자료구조로 계층적 관계를 표현하는 자료구조로 무엇인가를 저장하고 꺼낸다는 사고보다는 자료구조의 표현에 집중한다.
- 트리를 구성하고 있는 구성 요소들 (용어)
    - Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미
    - Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선
    - Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미
    - Terminal Node(=leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미
    - Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함

## Binary Tree (이진 트리)

- 루트 노드를 중심으로 두 개의 서브 트리로 나눠짐 또한, 나눠진 두 서브 트리도 모두 이진 트리이어야 한다.
- 트리에서는 각 층별로 숫자를 매겨서 이를 트리의 Level이라고 한다. 레벨의 값은 0부터 시작하고 따라서 루트 노드의 레벨은 0이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 height(높이)라고 한다.

### Complete Binary Tree (완전 이진 트리)

- 모든 레벨이 꽉 찬 이진 트리 (포화 이진 트리)
- 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리
- 배열로 구성된 Binary Tree는 노드의 개수가 n개이고 root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서 parent(i) = i/2, left_child(i) = 2i, right_child(i) = 2i + 1의 index 값을 갖는다.

### BST (Binary Search Tree)

1. 규칙 (특정 데이터의 위치를 찾는데 사용)
    - 이진 탐색 트리의 노드에 저장된 키는 유일하다.
    - 부모의 키가 왼쪽 자식 노드의 키보다 크다.
    - 부모의 키가 오른쪽 자식 노드의 키보다 작다.
    - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
2. 시간 복잡도
    - 탐색 연산 : O(log n) == O(h)
        - 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문
        - 하지만, 이러한 이진 탐색 트리는 편항 트리가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문
        - 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case가 되고 시간 복잡도는 O(n)
    - 배열보다 많은 메모리를 사용하며 데이터를 저장했지만, 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생 이를 해결하기 위해 Rebalancing 기법이 등장
    - Rebalancing : 균형을 잡기 위한 트리 구조의 재조정 (이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 Red-Black Tree!)
  
## Binary Heap

1. 특징
    - 자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree
    - 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index부터 루트노트가 시작된다.
    - 이는 노드의 고유번호값과 배열의 index를 일치시켜 혼동을 줄이기 위함
    - Heap에는 최대 힙 (max heap), 최소 힙 (min heap) 두 종류가 존재
    - Max Heap : 각 노드의 값이 해당 children의 값보다 크거나 같은 complete binary tree (Min Heap은 그 반대!)
2. 시간 복잡도
    - 최대값을 찾는데 소요되는 시간 : O(1) ⇒ 루트 노드에 있는 값이 제일 크므로
    - 완전 이진 트리이기 때문에 배열을 사용해 효율적인 관리가 가능 (Random access가 가능)
    - 하지만, heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요 ⇒ 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지
    - 이런 경우에는 결국 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.

## Red Black Tree

- BST를 기반으로하는 트리 형식의 자료구조
- Red-Black Tree에 데이터를 저장하게 되면 search, insert, delete에 O(log n)의 시간 복잡도가 소요
- 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어
- 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 완전 이진 트리인 경우이다.

### Red-Black Tree의 정의

Red-black Tree는 다음의 성질들을 만족하는 BST이다.

1. 각 노드는 Red or Black이라는 색깔을 갖는다.
2. Root node의 색깔은 black이다.
3. 각 leaf node는 black이다.
4. 어떤 노드의 색깔이 red라면 두 개의 children의 색깔은 모두 black이다.
5. 각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes들을 포함하고 있다. 이를 해당 노드의 black-height라고 한다.
(Black-Height : 노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에  있는 black nodes들의 개수

### Red-Black Tree의 특징

1. 이진 탐색 트리이므로 BST의 특징을 모두 갖는다.
2. Root node부터 leaf node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 balanced 상태라고 한다.
3. 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 leaf node로 간주한다.

*cf) RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을  해결하기 위해 만들어진 자료구조이다. 이를 어떻게 해결한 것인가?*

### 삽입

우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 RED로 지정한다. Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다.
삽입 결과 RBT의 특성 위배(violation)시 노드의 색깔을 조정하고, Black-Height가 위배되었다면 rotation을 통해 height를 조정한다.

이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 Black-height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2미만으로 유지된다.

### 삭제

삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게된다.

