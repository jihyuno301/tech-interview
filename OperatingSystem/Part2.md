# 3. Operating System - Part2
### :book: Contents
- [동기와 비동기](#동기와-비동기)
- [프로세스 동기화](#프로세스-동기화)
- [메모리 관리 전략](#메모리-관리-전략)
- [가상 메모리](#가상-메모리)
- [캐시의 지역성](#캐시의-지역성)


---

<br>

### 동기와-비동기
- **동기(synchronous: 동시에 일어나는)**
  - 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다.   
  - 바로 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다.   
  - \* 요청과 결과가 한 자리에서 일어남   
    \* A노드와 B노드 사이의 작업 처리 단위(Transaction)를 동시에 맞추겠다
![동기](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdi7gN2%2FbtqBOCQVV95%2FfudKCIJysd6tPmRCrgKkTK%2Fimg.jpg)
1. A의 계좌는 10,000원을 뺄 생각을 하고 있다.
2. A의 계좌가 B의 계좌에 10,000원을 송금한다.
3. B의 계좌는 10,000원을 받았다는 걸 인지하고, A의 계좌에 10,000원을 받았다고 전송한다.
4. A, B 계좌 각 각 차감과 증거가 동시에 발생하였다.

A의 계좌와 B의 계좌는 서로 요청과 응답(1~3 과정)을 확인한 수 같은 일을 동시에 진행하였다. (4번 과정)

<br>

- **비동기(Asynchronous: 동시에 일어나지 않는)**
  - 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 거라는 약속이다.
  - \* 요청한 그 자리에서 결과가 주어지지 않음   
    \* 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.
    
![비동기](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbwVpXK%2FbtqBS6pf3IG%2FkmS8ylFIz39Kj2VLK0ESD1%2Fimg.jpg)
1. 학생은 시험문제를 푼다
2. 시험문제를 모두 푼 학생은 선생님에게 전송한다.
3. 선생은 학생의 시험지를 채점한다.
4. 채점이 다 된 시험지를 학생에게 전송한다.
5. 학생은 선생이 전송한 시험지를 받아 결과를 확인한다.

> 학생과 선생은 시험지라는 연결고리가 있지만 시험지에 행하는 행위(목적)는 서로 다르다.   
학생은 시험지를 푸는 역할을 하고 선생은 시험지를 채점하는 역할을 한다. 서로의 행위(목적)가 다르기때문에   
둘의 작업 처리 시간은 일치하지 않고, 일치하지 않아도 된다.

<br>

- **블록과 논블록의 차이**
  - 블록 상태 : 학생이 시험지를 선생에게 건넨 후 가만히 앉아 채점이 끝나서 시험지를 돌려받기만을 기다리는 것
  - 논블록 상태 : 학생이 시험지를 건넨 후 선생에게 채점이 완료되었다는 전송을 받기 전까지 다른 일을 할 수 있는 것
  
>-[https://byeongmoo.tistory.com/5](https://byeongmoo.tistory.com/5)
<br>

### 프로세스-동기화
- 프로세스 동기화(Process Synchronization)란?
  - 협력하는 프로레스들 사이의 실행 순서의 규칙을 보장하며 공유되는 데이터의 일관성을 보장한다.

<br>

**동기화 작업이 요구되는 상황?**
- 병행 프로세스 : 스케줄링을 통해서 CPU에서 프로세스들을 교체해나가며 여러 개의 프로세스를 동시에 실행하는 것처럼 보이게 하는 것
  - 종류
  1. 독립적 프로세스 (Independent process)
      - 단일 처리 시스템 (cpu 1개) 에서 각각 독립적으로 여러 프로세스들이 병행 수행되는 것
      - 실행중인 다른 프로세스들에게 영향을 주지도, 받지도 않고, 데이터를 공유하지 않음
  2. 협력 프로세스 (cooperaitng process)
      - 다중 처리 시스템에서 모든 입출력 장치와 메모리에 참조가 가능하기 때문에 다른 프로세스의 실행에 영향을 주거나 받는다.
      - 주로 스레드와 같이 논리 주소 공간을 통해 공유하거나 공유 변수, 공유 파일을 통해 데이터를 공유한다.
    
- 비동기적 수행 방식과 동기적 수행 방식
  - 비동기적 수행 방식 : 프로세스들 간에 어떤 정교한 협력을 통해서만 기능을 수행
  - 동기적 수행 방식 : 프로세스 동기화가 필요한 방식
  
> 즉, **프로세스 동기화**란 I/O 장치나 메모리와 같은 자원을   
한번에 하나의 프로세스만 이용하도록 제어해 데이터의 일관성을 보장해주는 것이다.

<br>

- **경쟁 조건 (Race Condition)**
  - 공유된 자원의 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태
  1. 여러 프로세스가 공유 데이터를 동시에 조작할 때, 실행의 특정 순서에 따라 결과가 달라지는 상황
  2. 공유 데이터 조작을 원자적 연산으로 처리하면 경쟁 조건은 발생하지 않는다.
> 원자적 연산 : 어떤 연산의 결과가 외부의 간섭에 관계없이 전체가 완료되든지 전혀 실행되지 않는 상태로만 나타남

<br>

- **임계 영역 (Critical Section)**
  - 동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역
  - 경쟁 조건이 발생할 수 있는 프로그램 코드 부분
    - 다른 프로세스와 공유하는 변수나 파일을 변경
  - 임계 영역 문제의 해결 방법
    - 한 번에 하나의 프로세스만 임계 영역을 실행하도록 보장 (Lock)
      - 적절한 동기화 기법을 설계
      - 임계 영역 전체를 원자적으로 처리하는 효과

<br>

- **임계 영역 문제 해결을 위한 기본 조건**
  - 3가지 조건을 모두 만족해야지 안전한 동기화가 가능하다 (=임계 영역 문제를 해결)
  1. **상호 배제 (Mutual Exclusion)**
      - 어떤 프로세스가 자신의 임계 영역 내에서 실행 중일 때 다른 프로세스는 각자의 임계 영역으로 진입할 수 없다.
  2. **진행 (Progress)**
      - 임계 영역에서 실행 중인 프로세스가 없다면, 임계 영역으로 진입하려는 프로세스들 중 하나는 유한한 시간 내에 진입할 수 있어야 한다.
  3. **한정된 대기 (Bounded waiting)**
      - 한 프로세스가 임계 영역에 대한 진입을 요청한 후에는 다른 프로세스의 임계 영역 진입이 유한한 횟수로 제한되어야 한다.   
        즉, 임계 영역에 대한 진입 요청 후 무한히 기다리지 않는다.

>[https://jungwoon.github.io/os/2019/07/31/Process-Synchronization/](https://jungwoon.github.io/os/2019/07/31/Process-Synchronization/)

### 메모리-관리-전략
- 메모리 관리 전략(Memory Managing Strategy)이란?
  - 메모리 용량이 증가함에 따라 프로그램의 크기 또한 계속 증가하고 있기 떄문에 메모리는 언제나 부족
  - 제한된 물리 메모리의 효율적인 사용과 메모리 참조 방식을 제공하기 위한 전략
  
- 효과적인 메모리 사용
  1. 동적 적재(Dynamic Loading)
    - 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재하는 기법
    - 모든 루틴(ex. 오류처리)과 데이터(ex. 배열)는 항상 사용하지 않고, 실행 시 필요하다면 그때 해당 부분을 메모리에 적재
  2. 동적 연결(Dynamic Linking)
    - 라이브러리 루틴연결을 컴파일 시점에 하는 것이 아닌 실행 시점까지 미루는 기법
  3. 스와핑(Swapping)
    - CPU에서 실행중이지 않는 프로세스는 저장장치의 Swap 영역으로 이동(Swap in/Swap out)해 메모리를 확보
    - 문맥 교환으로 인한 오버헤드가 발생할 수 있고 속도가 느려지지만, 메모리 공간 확보에는 효율적
  
<br>
  
- 메모리 관리 전략의 종류
1. 연속 메모리 할당
- 프로세스를 메모리에 연속적으로 할당하는 기법
- 할당과 제거를 반복하다보면 Scattered Holes가 생겨나고 이로 인한 외부 단편화가 발생

  (1) 연속 메모리 할당에서 외부 단편화를 줄이기 위한 할당 방식   
  a. 최초 적합(First fit)
  - 가장 처음 만나는 빈 메모리 공간에 프로세스를 할당
  - 빠름

  b. 최적 적합(Best fit)
  - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당

  c. 최악 적합(Worst fit)
  - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당
  - 이렇게 생긴 빈 메모리 공간에 또 다른 프로세스를 할당할 수 있을 거라는 가정에 기인

2) 페이징(Paging)
- 메모리 공간이 연속적으로 할당되어야 한다는 제약조건을 없애는 메모리 관리 전략
- 논리 메모리는 고정크기의 페이지, 물리메모리는 고정크기의 프레임 블록으로 나누어 관리
- 프로세스가 사용하는 공간을 논리 메모리에서 여러 개의 페이지로 나누어 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장
- MMU(Memory Management Unit)의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 함
- 내부 단편화 발생

3) 세그멘테이션(Segmentation)
- 페이징 기법과 반대로 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할
- 외부 단편화 발생
 
4) 세그멘테이션 페이징 혼용 기법
- 페이징과 세그멘테이션도 각각 내부 단편화와 외부 단편화가 발생
- 페이징과 세그멘테이션을 혼용해 이러한 단편화를 최대한 줄이는 전략
- 프로세스를 세그먼트(논리적 기능 단위)로 나눈 다음 세그먼트를 다시 페이지 단위로 나누어 관리
- 매핑 테이블을 두 번 거쳐야하므로 속도가 느려짐
  
>[https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy](https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy)

### 가상-메모리
- **가상 메모리(Virtual Memory)란?**
  - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술로 실제 메모리보다 많이 보이게 하는 기술이다.
  - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸 때만 물리 주소로 바꿔주면 된다.
    - virtual address(가상주소) : 프로세스가 참조하는 주소
    - physical address : 실제 메모리 주소
  - 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있다.
  
- **가상 메모리가 필요한 이유?**
  - 메모리 용량 부족 이슈
  - 프로세스 메모리 영역 간에 침범 이슈
  
- **페이징(paging)**
  - 가상 메모리상의 주소 공간을 일정한 크기의 페이지로 분할하고 실제 메모리 또한 가상메모리와 같은 크기로 분할한다.
  - 페이지의 크기는 대부분 4Kbyte를 사용한다.
  - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리한다.
  
- **페이지 테이블**
  - 가상 메모리의 페이지와 실제 메모리의 페이지를 연결시켜주기 위한 매핑 테이블
  - 가상 메모리의 페이지 넘버와 실제 메모리의 페이지 프레임을 하나의 순서쌍으로 정의하고 있는 도표
  - 이러한 페이지 테이블이 존재하면, 성능은 하락한다. 따라서 MMU라는 H/W를 통해 매핑 시킨다. (이를 통해 메모리 접근 횟수 감소)
> CPU는 가상 주소 접근시 mmu 하드웨어 장치를 통해 물리 메모리에 접근한다.

- **페이징 시스템**
  - 프로세스(4GB)의 PCB에 Page Table 구조체를 가르키는 주소가 들어있다.
  - Page Table에는 가상 주소와 물리 주소간 매핑 정보가 들어 있다.
  
- **페이징 시스템 구조**
  - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
  - 가상주소 v = (p,d)라면
    - p : 페이지 번호
    - d : 페이지 처음부터 얼마 떨어진 위치인지
  - paging system 동작
    - 해당 프로세스에서 특정 가상 주소 액세스를 하려면?
    - 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는지 확인
    - page 번호가 있으면 이 page가 맵핑된 첫 물리 주소를 알아내고(p')
    - p' + d가 실제 물리 주소가 된다.
    
> [https://velog.io/@pa324/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EB%85%90-4dk2q3ivff](https://velog.io/@pa324/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EB%85%90-4dk2q3ivff)

### 캐시의-지역성
- 캐시 메모리
  - 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리
  - 이러한 역할을 수행하기 위해서는 CPU 가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 함
  - 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우됨
  
- 지역성(Locality)의 원리
  - 캐시 메모리의 적중율(Hit rate)을 극대화 시키기 위한 원리
  - 전제조건 : 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다
  - 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성
  - 종류
    - 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.
    - 공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
    
> [https://k39335.tistory.com/38](https://k39335.tistory.com/38)
